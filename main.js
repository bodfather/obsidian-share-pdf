/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SharePDFPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

var DEFAULT_SETTINGS = {
  includeFrontmatter: false,
  fontSize: 11,
  pdfFolder: "PDFs",
  cssOverride: "",
  useTheme: true, // New toggle for using theme CSS
  replaceEmojis: false, // Replace emojis with [emoji:name] instead of removing them
  colorMode: "auto", // "auto", "light", or "dark"
  includeTitle: true, // Show document name at top of PDF
  removeWikilinks: false, // Remove all wikilinks from PDF
  marginWidth: "normal", // "narrow", "normal", "wide"
  warnOnOverwrite: true, // Warn before overwriting existing PDFs
  pdfNamingStyle: "filename", // "filename", "sentence-case", or "first-h1"
  showPageNumbers: false, // Show page numbers at bottom of each page
  pageNumberAlignment: "center" // "left", "center", or "right"
};

// Confirmation modal for overwrite warning
var ConfirmOverwriteModal = class extends import_obsidian.Modal {
  constructor(app, filename, onConfirm, onRename) {
    super(app);
    this.filename = filename;
    this.onConfirm = onConfirm;
    this.onRename = onRename;
  }

  onOpen() {
    const { contentEl } = this;
    contentEl.empty();

    contentEl.createEl("h2", { text: "File already exists" });
    contentEl.createEl("p", { text: `The file "${this.filename}.pdf" already exists.` });

    // Add input field for new filename
    const inputContainer = contentEl.createDiv({ cls: "modal-input-container" });
    inputContainer.createEl("label", { text: "New filename:" });
    const inputEl = inputContainer.createEl("input", {
      type: "text",
      value: this.filename,
      cls: "modal-input"
    });
    inputEl.style.width = "100%";
    inputEl.style.marginTop = "8px";
    inputEl.style.marginBottom = "16px";

    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });

    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.close();
    });

    const renameButton = buttonContainer.createEl("button", { text: "Rename" });
    renameButton.addEventListener("click", () => {
      const newName = inputEl.value.trim();
      if (newName && newName !== this.filename) {
        this.onRename(newName);
        this.close();
      } else if (newName === this.filename) {
        // Same name, treat as overwrite
        this.onConfirm();
        this.close();
      } else {
        new import_obsidian.Notice("Please enter a valid filename");
      }
    });

    const confirmButton = buttonContainer.createEl("button", { text: "Overwrite", cls: "mod-cta" });
    confirmButton.addEventListener("click", () => {
      this.onConfirm();
      this.close();
    });

    // Focus and select the input field
    setTimeout(() => {
      inputEl.focus();
      inputEl.select();
    }, 10);

    // Handle Enter key in input
    inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        renameButton.click();
      }
    });
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// Helper functions for PDF naming
function convertToSentenceCaseKeepDate(filename) {
  // Match date prefix (YYYY-MM-DD-) and capture the rest
  const match = filename.match(/^(\d{4}-\d{2}-\d{2})-(.+)$/);
  if (!match) return filename; // No date, return as-is

  const date = match[1];
  let rest = match[2];

  // Replace hyphens/underscores with spaces
  rest = rest.replace(/[-_]/g, ' ');

  // Sentence case each word
  rest = rest.split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');

  return `${date} ${rest}`;
}

function convertToSentenceCase(filename) {
  // Remove date prefix if present (e.g., "2024-01-15-")
  let cleaned = filename.replace(/^\d{4}-\d{2}-\d{2}-/, '');

  // Replace hyphens and underscores with spaces
  cleaned = cleaned.replace(/[-_]/g, ' ');

  // Capitalize first letter of each word
  return cleaned.split(' ')
Â Â Â Â .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
Â Â Â Â .join(' ');
}

function extractFirstH1(content) {
  // Remove frontmatter first
  const withoutFrontmatter = content.replace(/^---\n[\s\S]*?\n---\n/, '');

  // Look for first H1 (# Title)
  const h1Match = withoutFrontmatter.match(/^#\s+(.+)$/m);
  if (h1Match) {
    return h1Match[1].trim();
  }

  return null;
}

var SharePDFPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "share-note-as-pdf",
      name: "Share current note as PDF",
      checkCallback: (checking) => {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (activeView) {
          if (!checking) {
            this.shareNotePDF(activeView);
          }
          return true;
        }
        return false;
      }
    });
 //   if (import_obsidian.Platform.isMobile) {
      this.addRibbonIcon("share", "Share as PDF", async () => {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (activeView) {
          await this.shareNotePDF(activeView);
        } else {
          new import_obsidian.Notice("No active note to share");
        }
      });
 //   }
    this.addSettingTab(new SharePDFSettingTab(this.app, this));
  }

  async shareNotePDF(view) {
    try {
      const file = view.file;
      if (!file) {
        new import_obsidian.Notice("No file to share");
        return;
      }
      new import_obsidian.Notice("Generating PDF...");
      let content = await this.app.vault.read(file);
      if (!this.settings.includeFrontmatter) {
        content = content.replace(/^---\n[\s\S]*?\n---\n/, "");
      }

      // Determine PDF filename based on naming style setting
      let pdfName = file.basename;
      if (this.settings.pdfNamingStyle === "sentence-case") {
        pdfName = convertToSentenceCase(file.basename);
      } else if (this.settings.pdfNamingStyle === "sentence-case-date") {
        pdfName = convertToSentenceCaseKeepDate(file.basename);
      } else if (this.settings.pdfNamingStyle === "first-h1") {
        const h1Title = extractFirstH1(content);
        if (h1Title) {
          pdfName = h1Title;
        } else {
          // Fallback to sentence case if no H1 found
          pdfName = convertToSentenceCase(file.basename);
        }
      }
      // else use filename as-is (default)

      const pdfBlob = await this.generatePDF(pdfName, content);
      await this.sharePDF(pdfBlob, pdfName);
    } catch (error) {
      console.error("Error sharing:", error);
      new import_obsidian.Notice(`Error: ${error.message}`);
    }
  }

  // Helper to validate and sanitize color values
  getValidColor(colorValue, fallback) {
    if (!colorValue) return fallback;

    // Check if color contains unsupported CSS functions like hsl(from ...)
    if (colorValue.includes('from ') || colorValue.includes('calc(')) {
      return fallback;
    }

    // Simple validation - check if it looks like a valid color
    const colorPattern = /^(#[0-9a-fA-F]{3,8}|rgb|hsl|var\()/;
    if (!colorPattern.test(colorValue.trim())) {
      return fallback;
    }

    return colorValue;
  }

  // Helper to apply text-transform CSS property
  applyTextTransform(text, transform) {
    if (!transform || transform === "none") return text;

    switch (transform) {
      case "uppercase":
        return text.toUpperCase();
      case "lowercase":
        return text.toLowerCase();
      case "capitalize":
        return text.split(' ').map(word =>
          word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
        ).join(' ');
      default:
        return text;
    }
  }

  // Helper to parse CSS color to jsPDF-compatible format
  parseColorForPDF(cssColor) {
    if (!cssColor) return null;

    // If already an array (e.g., [r, g, b] or [r, g, b, a]), return as-is
    if (Array.isArray(cssColor)) return cssColor;

    // Handle hex colors
    if (cssColor.startsWith('#')) {
      return cssColor;
    }

    // Handle rgb/rgba format: rgb(255, 255, 255) or rgba(255, 255, 255, 1)
    const rgbMatch = cssColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
    if (rgbMatch) {
      return [parseInt(rgbMatch[1]), parseInt(rgbMatch[2]), parseInt(rgbMatch[3])];
    }

    // Handle hsl format (basic conversion)
    const hslMatch = cssColor.match(/hsla?\((\d+),\s*(\d+)%,\s*(\d+)%/);
    if (hslMatch) {
      // Convert HSL to RGB
      const h = parseInt(hslMatch[1]) / 360;
      const s = parseInt(hslMatch[2]) / 100;
      const l = parseInt(hslMatch[3]) / 100;

      let r, g, b;
      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }

      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    // If we can't parse it, return as-is and hope jsPDF can handle it
    return cssColor;
  }

  getPageMargins(pageWidth) {
    // Fetch Obsidian's margin and width settings
    const style = getComputedStyle(document.body);

    // Get file-line-width (default 700px if not set)
    const fileLineWidth = parseInt(style.getPropertyValue("--file-line-width")) || 700;

    // Get file-margins (default 44px if not set)
    const fileMargins = parseInt(style.getPropertyValue("--file-margins")) || 44;

    // Calculate margin as proportion of available space
    // In Obsidian: total available width = viewport, content width = file-line-width, margins = file-margins
    // Assuming typical viewport of ~1000px for calculation
    const assumedViewportWidth = 1000;
    const contentAreaWidth = fileLineWidth + (fileMargins * 2);
    const sideMargins = (assumedViewportWidth - contentAreaWidth) / 2;
    const totalMargin = sideMargins + fileMargins;

    // Calculate proportion: totalMargin / assumedViewportWidth
    const marginProportion = totalMargin / assumedViewportWidth;

    // Apply proportion to PDF page width
    let calculatedMargin = pageWidth * marginProportion;

    // Apply margin width setting
    if (this.settings.marginWidth === "narrow") {
      calculatedMargin = calculatedMargin * 0.6; // 60% of normal
    } else if (this.settings.marginWidth === "wide") {
      calculatedMargin = calculatedMargin * 1.4; // 140% of normal
    }
    // "normal" uses calculated margin as-is

    // Ensure margin is reasonable (between 5mm and 30mm)
    calculatedMargin = Math.max(5, Math.min(30, calculatedMargin));

    return calculatedMargin;
  }

  getThemeStyles() {
    // Find the body element to get actual theme styles
    let sourceEl = document.body;
    let tempBodyClasses = null;

    // If color mode override is set, temporarily modify body classes
    if (this.settings.colorMode !== "auto") {
      // Save original body classes
      tempBodyClasses = document.body.className;

      // Override with specific theme mode
      if (this.settings.colorMode === "light") {
        document.body.classList.remove("theme-dark");
        document.body.classList.add("theme-light");
      } else if (this.settings.colorMode === "dark") {
        document.body.classList.remove("theme-light");
        document.body.classList.add("theme-dark");
      }

      // Use body as source since we've modified its classes
      sourceEl = document.body;
    }

    // If CSS override is present, create a temp element to layer the overrides
    if (this.settings.cssOverride) {
      const tempEl = document.createElement("div");
      tempEl.style.display = "none";
      tempEl.className = document.body.className;
      document.body.appendChild(tempEl);

      const rules = this.settings.cssOverride;
      const varMatches = rules.match(/--[a-zA-Z0-9-]+:\s*[^;}]+/g) || [];
      varMatches.forEach(match => {
        const [prop, val] = match.split(':').map(s => s.trim().replace(';', ''));
        tempEl.style.setProperty(prop, val);
      });

      sourceEl = tempEl;
    }

    // Fetch styles only if useTheme is true
    const style = this.settings.useTheme ? getComputedStyle(sourceEl) : {};
    const textNormal = this.settings.useTheme ? this.getValidColor(style.getPropertyValue("--text-normal"), "#000000") : "#000000";

    // Create temporary heading elements to detect text-transform
    // We need to create them within a markdown-preview-view container to match theme selectors
    let h1Transform = "none", h2Transform = "none", h3Transform = "none";
    if (this.settings.useTheme) {
      const tempContainer = document.createElement("div");
      tempContainer.className = "markdown-preview-view";
      tempContainer.style.display = "none";

      const tempH1 = document.createElement("h1");
      const tempH2 = document.createElement("h2");
      const tempH3 = document.createElement("h3");

      tempContainer.appendChild(tempH1);
      tempContainer.appendChild(tempH2);
      tempContainer.appendChild(tempH3);

      sourceEl.appendChild(tempContainer);

      h1Transform = getComputedStyle(tempH1).getPropertyValue("text-transform");
      h2Transform = getComputedStyle(tempH2).getPropertyValue("text-transform");
      h3Transform = getComputedStyle(tempH3).getPropertyValue("text-transform");

      sourceEl.removeChild(tempContainer);
    }

    const styles = {
      fontFamily: this.settings.useTheme ? style.getPropertyValue("--font-text-theme") || "Helvetica" : "Helvetica",
      textColor: textNormal,
      headingColor: this.settings.useTheme ? this.getValidColor(style.getPropertyValue("--h1-color"), textNormal) : textNormal,
      codeColor: this.settings.useTheme ? this.getValidColor(style.getPropertyValue("--text-normal-60"), textNormal) : textNormal,
      backgroundColor: this.settings.useTheme ? this.getValidColor(style.getPropertyValue("--background-primary"), "#FFFFFF") : "#FFFFFF",
      blockquoteBorderColor: this.settings.useTheme ? this.getValidColor(style.getPropertyValue("--blockquote-border") || style.getPropertyValue("--text-accent"), textNormal) : textNormal,
      listMarkerColor: this.settings.useTheme ? this.getValidColor(style.getPropertyValue("--list-marker-color"), textNormal) : textNormal,
      boldColor: this.settings.useTheme ? this.getValidColor(style.getPropertyValue("--bold-color"), textNormal) : textNormal,
      h1Size: this.settings.useTheme ? parseFloat(style.getPropertyValue("--h1-size")) * this.settings.fontSize / 100 || this.settings.fontSize + 4 : this.settings.fontSize + 4,
      h2Size: this.settings.useTheme ? parseFloat(style.getPropertyValue("--h2-size")) * this.settings.fontSize / 100 || this.settings.fontSize + 2 : this.settings.fontSize + 2,
      h3Size: this.settings.useTheme ? parseFloat(style.getPropertyValue("--h3-size")) * this.settings.fontSize / 100 || this.settings.fontSize + 1 : this.settings.fontSize + 1,
      h1Transform: h1Transform,
      h2Transform: h2Transform,
      h3Transform: h3Transform,
      headingSpacing: 0,
      listIndent: this.settings.useTheme ? parseFloat(style.getPropertyValue("--list-indent-editing")) / 2.83465 || 7 : 7 // 20px â‰ˆ 7mm
    };

    // Clean up temporary element if created
    if (sourceEl !== document.body) {
      document.body.removeChild(sourceEl);
    }

    // Restore original body classes if we modified them
    if (tempBodyClasses !== null) {
      document.body.className = tempBodyClasses;
    }

    return styles;
  }

  // Helper function to calculate vertical space needed for footnotes
  calculateFootnoteSpace(pageNumber, pageFootnotes, footnoteDefinitions, doc, maxWidth) {
    if (!pageFootnotes[pageNumber] || pageFootnotes[pageNumber].length === 0) {
      return 0; // No footnotes on this page
    }

    let totalHeight = 0;

    // Space for separator line and gap above it
    totalHeight += 5; // 5mm spacing before separator
    totalHeight += 3; // 3mm gap after separator

    // Calculate space for each footnote
    for (const ref of pageFootnotes[pageNumber]) {
      const footnoteText = footnoteDefinitions[ref] || "";
      const footnotePrefix = `${ref}. `;

      // Calculate prefix width
      const prefixWidth = doc.getTextWidth(footnotePrefix);

      // Calculate how many lines this footnote will take
      const wrappedText = doc.splitTextToSize(footnoteText, maxWidth - prefixWidth);

      // Each line is 4.0mm in height
      totalHeight += wrappedText.length * 4.0;
    }

    return totalHeight;
  }

  async generatePDF(title, markdown) {
    await this.loadJsPDF();
    const jsPDF = window.jspdf.jsPDF;
    const doc = new jsPDF({ orientation: "portrait", unit: "mm", format: "a4" });
    const themeStyles = this.getThemeStyles();
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    const margin = this.getPageMargins(pageWidth);
    const maxWidth = pageWidth - margin * 2;
    let yPosition = margin;

    // Track footnotes per page
    const pageFootnotes = {}; // { pageNumber: [footnoteRefs] }
    const pageMaxY = {}; // Track maximum Y position per page

    // Apply background
    if (themeStyles.backgroundColor) {
      const bgColor = this.parseColorForPDF(themeStyles.backgroundColor);
      if (bgColor) {
        if (Array.isArray(bgColor)) {
          doc.setFillColor(bgColor[0], bgColor[1], bgColor[2]);
        } else {
          doc.setFillColor(bgColor);
        }
        doc.rect(0, 0, pageWidth, pageHeight, "F");
      }
    }

    // Title styling (only if includeTitle is true)
    if (this.settings.includeTitle) {
      doc.setFont(themeStyles.fontFamily, "bold");
      doc.setFontSize(18);
      const titleColor = this.parseColorForPDF(themeStyles.headingColor);
      if (Array.isArray(titleColor)) {
        doc.setTextColor(titleColor[0], titleColor[1], titleColor[2]);
      } else {
        doc.setTextColor(titleColor);
      }
      // Apply h1 text-transform to title
      const transformedTitle = this.applyTextTransform(title, themeStyles.h1Transform);
      const titleLines = doc.splitTextToSize(transformedTitle, maxWidth);
      doc.text(titleLines, margin, yPosition);
      yPosition += titleLines.length * 8;
    }

    // Content styling
    const lines = this.markdownToPlainText(markdown);
    const footnoteDefinitions = this._footnotes || {};

    for (const line of lines) {
      // Calculate space needed for footnotes on current page
      const currentPage = doc.internal.getCurrentPageInfo().pageNumber;
      const footnoteSpace = this.calculateFootnoteSpace(currentPage, pageFootnotes, footnoteDefinitions, doc, maxWidth);
      const effectiveMaxY = pageHeight - margin - footnoteSpace - 10;

      if (yPosition > effectiveMaxY) {
        doc.addPage();
        yPosition = margin;
        if (themeStyles.backgroundColor) {
          const bgColor = this.parseColorForPDF(themeStyles.backgroundColor);
          if (bgColor) {
            if (Array.isArray(bgColor)) {
              doc.setFillColor(bgColor[0], bgColor[1], bgColor[2]);
            } else {
              doc.setFillColor(bgColor);
            }
            doc.rect(0, 0, pageWidth, pageHeight, "F");
          }
        }
      }

      let indent = 0;
      let baseFontSize = this.settings.fontSize;
      let baseTextColor = themeStyles.textColor;

      // Set base styles based on line type
      if (line.type === "heading") {
        const size = line.level === 1 ? themeStyles.h1Size : line.level === 2 ? themeStyles.h2Size : themeStyles.h3Size;
        baseFontSize = size;
        baseTextColor = themeStyles.headingColor;
      } else if (line.type === "blockquote") {
        indent = 6; // Indent blockquotes
      } else if (line.isList) {
        // Apply indentation based on nesting level
        const nestLevel = line.nestLevel || 0;
        // Each nest level gets one additional indent unit
        indent = themeStyles.listIndent * (1 + nestLevel);
      }

      // Calculate line height based on content type
      const fontSizeMm = baseFontSize * 0.352778;
      let lineHeight, paragraphSpacing;

      if (line.type === "heading") {
        lineHeight = fontSizeMm * 1.1;
        paragraphSpacing = fontSizeMm * -0.2;
      } else if (line.type === "blockquote") {
        lineHeight = fontSizeMm * 1.4;
        paragraphSpacing = fontSizeMm * 0.0;
      } else if (line.isList) {
        lineHeight = fontSizeMm * 1.4;
        paragraphSpacing = fontSizeMm * 0.0;
      } else {
        lineHeight = fontSizeMm * 1.4;
        paragraphSpacing = fontSizeMm * -0.3;
      }

      // Store starting position for blockquote border
      const startYPosition = yPosition;

      // Render segments with proper formatting
      let currentLine = [];
      let currentLineWidth = 0;
      let isFirstLine = true;
      let listMarkerWidth = 0;

      // Calculate list marker width for list items (bullets or numbers)
      if (line.isList && line.segments.length > 0) {
        const firstSegment = line.segments[0].text;
        // Check if first segment is a bullet or number
        if (firstSegment === "â€¢  " || /^\d+\.\s+$/.test(firstSegment)) {
          doc.setFont(themeStyles.fontFamily, "normal");
          doc.setFontSize(baseFontSize);
          listMarkerWidth = doc.getTextWidth(firstSegment);
        }
      }

      for (const segment of line.segments) {
        // Set font style based on segment
        let fontStyle = "normal";
        let fontFamily = themeStyles.fontFamily;
        let fontSize = baseFontSize;
        let textColor = baseTextColor;

        // Check if this is a list marker segment (bullet or number)
        const isListMarker = line.isList && (segment.text === "â€¢  " || /^\d+\.\s+$/.test(segment.text));

        if (line.type === "heading") {
          fontStyle = "bold";
        }

        if (segment.style === "bold") {
          fontStyle = "bold";
          textColor = themeStyles.boldColor;
        } else if (segment.style === "italic") {
          fontStyle = "italic";
        } else if (segment.style === "code") {
          fontFamily = "Courier";
          fontSize = baseFontSize - 1;
          textColor = themeStyles.codeColor;
        } else if (segment.style === "superscript") {
          fontSize = baseFontSize * 0.7; // Smaller font for superscript
          // Track footnote reference on current page
          if (segment.footnoteRef) {
            const currentPage = doc.internal.getCurrentPageInfo().pageNumber;
            if (!pageFootnotes[currentPage]) {
              pageFootnotes[currentPage] = [];
            }
            if (!pageFootnotes[currentPage].includes(segment.footnoteRef)) {
              pageFootnotes[currentPage].push(segment.footnoteRef);
            }
          }
        } else if (isListMarker) {
          textColor = themeStyles.listMarkerColor;
          // Apply opacity based on nesting level for bullets
          if (segment.isBullet) {
            const nestLevel = line.nestLevel || 0;
            if (nestLevel >= 2) {
              // Level 2+: 50% opacity (lightest)
              const parsed = this.parseColorForPDF(textColor);
              if (Array.isArray(parsed)) {
                textColor = [parsed[0], parsed[1], parsed[2], 0.5];
              }
            } else if (nestLevel === 1) {
              // Level 1: 75% opacity (lighter)
              const parsed = this.parseColorForPDF(textColor);
              if (Array.isArray(parsed)) {
                textColor = [parsed[0], parsed[1], parsed[2], 0.75];
              }
            }
            // Level 0 keeps default opacity (1.0)
          }
        }

        doc.setFont(fontFamily, fontStyle);
        doc.setFontSize(fontSize);
        const parsedColor = this.parseColorForPDF(textColor);
        if (Array.isArray(parsedColor)) {
          if (parsedColor.length === 4) {
            // Has alpha channel
            doc.setTextColor(parsedColor[0], parsedColor[1], parsedColor[2]);
            doc.setGState(new doc.GState({ opacity: parsedColor[3] }));
          } else {
            doc.setTextColor(parsedColor[0], parsedColor[1], parsedColor[2]);
          }
        } else {
          doc.setTextColor(parsedColor);
        }

        // Apply text-transform for headings
        let segmentText = segment.text;
        if (line.type === "heading") {
          const transform = line.level === 1 ? themeStyles.h1Transform :
                           line.level === 2 ? themeStyles.h2Transform :
                           themeStyles.h3Transform;
          segmentText = this.applyTextTransform(segmentText, transform);
        }

        // Split segment text into words for wrapping
        const words = segmentText.split(' ');

        for (let i = 0; i < words.length; i++) {
          const word = i === words.length - 1 ? words[i] : words[i] + ' ';
          const wordWidth = doc.getTextWidth(word);

          // For wrapped lines in lists, account for list marker width in available space
          const effectiveIndent = (line.isList && !isFirstLine) ? indent + listMarkerWidth : indent;
          const availableWidth = maxWidth - effectiveIndent;

          // Check if word fits on current line
          if (currentLineWidth + wordWidth > availableWidth && currentLine.length > 0) {
            // Render current line
            const renderIndent = (line.isList && !isFirstLine) ? indent + listMarkerWidth : indent;
            let renderX = margin + renderIndent;

            for (const item of currentLine) {
              doc.setFont(item.fontFamily, item.fontStyle);
              doc.setFontSize(item.fontSize);
              const itemColor = this.parseColorForPDF(item.textColor);
              if (Array.isArray(itemColor)) {
                doc.setTextColor(itemColor[0], itemColor[1], itemColor[2]);
              } else {
                doc.setTextColor(itemColor);
              }
              // Apply opacity if needed
              if (item.opacity < 1.0) {
                doc.setGState(new doc.GState({ opacity: item.opacity }));
              }
              // Render superscript slightly raised
              const yOffset = item.isSuperscript ? -2 : 0;
              doc.text(item.text, renderX, yPosition + yOffset);
              // Reset opacity
              if (item.opacity < 1.0) {
                doc.setGState(new doc.GState({ opacity: 1.0 }));
              }
              renderX += item.width;
            }

            // Move to next line
            yPosition += lineHeight;
            currentLine = [];
            currentLineWidth = 0;
            isFirstLine = false;

            // Check if we need a new page
            const currentPageInner = doc.internal.getCurrentPageInfo().pageNumber;
            const footnoteSpaceInner = this.calculateFootnoteSpace(currentPageInner, pageFootnotes, footnoteDefinitions, doc, maxWidth);
            const effectiveMaxYInner = pageHeight - margin - footnoteSpaceInner - 10;

            if (yPosition > effectiveMaxYInner) {
              doc.addPage();
              yPosition = margin;
              if (themeStyles.backgroundColor) {
                const bgColor = this.parseColorForPDF(themeStyles.backgroundColor);
                if (bgColor) {
                  if (Array.isArray(bgColor)) {
                    doc.setFillColor(bgColor[0], bgColor[1], bgColor[2]);
                  } else {
                    doc.setFillColor(bgColor);
                  }
                  doc.rect(0, 0, pageWidth, pageHeight, "F");
                }
              }
            }
          }

          // Add word to current line
          currentLine.push({
            text: word,
            fontFamily: fontFamily,
            fontStyle: fontStyle,
            fontSize: fontSize,
            textColor: textColor,
            width: wordWidth,
            opacity: Array.isArray(parsedColor) && parsedColor.length === 4 ? parsedColor[3] : 1.0,
            isSuperscript: segment.style === "superscript"
          });
          currentLineWidth += wordWidth;
        }
      }

      // Render remaining line
      if (currentLine.length > 0) {
        const renderIndent = (line.isList && !isFirstLine) ? indent + listMarkerWidth : indent;
        let renderX = margin + renderIndent;

        for (const item of currentLine) {
          doc.setFont(item.fontFamily, item.fontStyle);
          doc.setFontSize(item.fontSize);
          const itemColor = this.parseColorForPDF(item.textColor);
          if (Array.isArray(itemColor)) {
            doc.setTextColor(itemColor[0], itemColor[1], itemColor[2]);
          } else {
            doc.setTextColor(itemColor);
          }
          // Apply opacity if needed
          if (item.opacity < 1.0) {
            doc.setGState(new doc.GState({ opacity: item.opacity }));
          }
          // Render superscript slightly raised
          const yOffset = item.isSuperscript ? -2 : 0;
          doc.text(item.text, renderX, yPosition + yOffset);
          // Reset opacity
          if (item.opacity < 1.0) {
            doc.setGState(new doc.GState({ opacity: 1.0 }));
          }
          renderX += item.width;
        }
        yPosition += lineHeight;
      }

      // Draw left border for blockquotes after rendering all lines
      if (line.type === "blockquote") {
        const borderColor = this.parseColorForPDF(themeStyles.blockquoteBorderColor);
        if (Array.isArray(borderColor)) {
          doc.setDrawColor(borderColor[0], borderColor[1], borderColor[2]);
        } else {
          doc.setDrawColor(borderColor);
        }
        doc.setLineWidth(0.5);
        const borderStart = startYPosition - 4;
        const borderEnd = yPosition - 4;
        doc.line(margin + 2, borderStart, margin + 2, borderEnd);
      }

      // Add extra spacing after the paragraph
      yPosition += paragraphSpacing;

      // Track maximum Y position for current page
      const trackingPage = doc.internal.getCurrentPageInfo().pageNumber;
      if (!pageMaxY[trackingPage] || yPosition > pageMaxY[trackingPage]) {
        pageMaxY[trackingPage] = yPosition;
      }
    }

    // Render footnotes on each page
    const totalPages = doc.internal.pages.length - 1; // -1 because first page is blank

    for (let i = 1; i <= totalPages; i++) {
      doc.setPage(i);

      // Render footnotes for this page if any
      if (pageFootnotes[i] && pageFootnotes[i].length > 0) {
        const textColor = this.parseColorForPDF(themeStyles.textColor);
        doc.setFont(themeStyles.fontFamily, "normal");
        doc.setFontSize(9);

        if (Array.isArray(textColor)) {
          doc.setTextColor(textColor[0], textColor[1], textColor[2]);
        } else {
          doc.setTextColor(textColor);
        }

        // Position footnotes after the content with some spacing
        // Ensure footnotes don't go below a reasonable position (leave room for page numbers)
        const contentEndY = pageMaxY[i] || margin;
        const footnoteSeparatorY = contentEndY + 5;

        // Draw a separator line above footnotes
        doc.setLineWidth(0.2);
        doc.line(margin, footnoteSeparatorY, margin + 30, footnoteSeparatorY);

        // Render each footnote
        let footnoteY = footnoteSeparatorY + 3;
        for (const ref of pageFootnotes[i]) {
          const footnoteText = footnoteDefinitions[ref] || "";
          const footnotePrefix = `${ref}. `;

          // Calculate the width of the footnote number prefix
          const prefixWidth = doc.getTextWidth(footnotePrefix);

          // Split the footnote text (without the prefix) for wrapping
          const wrappedText = doc.splitTextToSize(footnoteText, maxWidth - prefixWidth);

          // Render first line with the prefix
          doc.text(footnotePrefix + wrappedText[0], margin, footnoteY);

          // Render remaining wrapped lines indented to align with text
          for (let j = 1; j < wrappedText.length; j++) {
            footnoteY += 3.5;
            doc.text(wrappedText[j], margin + prefixWidth, footnoteY);
          }

          footnoteY += 3.5;
        }
      }
    }

    // Add page numbers if enabled
    if (this.settings.showPageNumbers) {
      const textColor = this.parseColorForPDF(themeStyles.textColor);

      for (let i = 1; i <= totalPages; i++) {
        doc.setPage(i);
        doc.setFont(themeStyles.fontFamily, "normal");
        doc.setFontSize(10);

        if (Array.isArray(textColor)) {
          doc.setTextColor(textColor[0], textColor[1], textColor[2]);
        } else {
          doc.setTextColor(textColor);
        }

        const pageText = `${i}`;
        const textWidth = doc.getTextWidth(pageText);
        let xPosition;

        // Calculate x position based on alignment setting
        if (this.settings.pageNumberAlignment === "left") {
          xPosition = margin;
        } else if (this.settings.pageNumberAlignment === "right") {
          xPosition = pageWidth - margin - textWidth;
        } else {
          // center (default)
          xPosition = (pageWidth - textWidth) / 2;
        }

        const yPositionPageNumber = pageHeight - margin / 2;

        doc.text(pageText, xPosition, yPositionPageNumber);
      }
    }

    return doc.output("blob");
  }

  handleEmojis(text) {
    // Common emoji to name mappings
    const emojiMap = {
      'ðŸ˜€': 'grinning', 'ðŸ˜ƒ': 'smiley', 'ðŸ˜„': 'smile', 'ðŸ˜': 'grin', 'ðŸ˜†': 'laughing',
      'ðŸ˜…': 'sweat_smile', 'ðŸ¤£': 'rofl', 'ðŸ˜‚': 'joy', 'ðŸ™‚': 'slightly_smiling',
      'ðŸ™ƒ': 'upside_down', 'ðŸ˜‰': 'wink', 'ðŸ˜Š': 'blush', 'ðŸ˜‡': 'innocent',
      'ðŸ¥°': 'smiling_face_with_hearts', 'ðŸ˜': 'heart_eyes', 'ðŸ¤©': 'star_struck',
      'ðŸ˜˜': 'kissing_heart', 'ðŸ˜—': 'kissing', 'ðŸ˜š': 'kissing_closed_eyes',
      'ðŸ˜™': 'kissing_smiling_eyes', 'ðŸ¥²': 'smiling_face_with_tear', 'ðŸ˜‹': 'yum',
      'ðŸ˜›': 'stuck_out_tongue', 'ðŸ˜œ': 'stuck_out_tongue_winking_eye',
      'ðŸ¤ª': 'zany_face', 'ðŸ˜': 'stuck_out_tongue_closed_eyes', 'ðŸ¤‘': 'money_mouth',
      'ðŸ¤—': 'hugging', 'ðŸ¤­': 'hand_over_mouth', 'ðŸ¤«': 'shushing', 'ðŸ¤”': 'thinking',
      'ðŸ¤': 'zipper_mouth', 'ðŸ¤¨': 'raised_eyebrow', 'ðŸ˜': 'neutral_face',
      'ðŸ˜‘': 'expressionless', 'ðŸ˜¶': 'no_mouth', 'ðŸ˜': 'smirk', 'ðŸ˜’': 'unamused',
      'ðŸ™„': 'rolling_eyes', 'ðŸ˜¬': 'grimacing', 'ðŸ¤¥': 'lying_face', 'ðŸ˜Œ': 'relieved',
      'ðŸ˜”': 'pensive', 'ðŸ˜ª': 'sleepy', 'ðŸ¤¤': 'drooling', 'ðŸ˜´': 'sleeping',
      'ðŸ˜·': 'mask', 'ðŸ¤’': 'thermometer_face', 'ðŸ¤•': 'head_bandage', 'ðŸ¤¢': 'nauseated',
      'ðŸ¤®': 'vomiting', 'ðŸ¤§': 'sneezing', 'ðŸ¥µ': 'hot', 'ðŸ¥¶': 'cold', 'ðŸ¥´': 'woozy',
      'ðŸ˜µ': 'dizzy_face', 'ðŸ¤¯': 'exploding_head', 'ðŸ¤ ': 'cowboy', 'ðŸ¥³': 'partying',
      'ðŸ¥¸': 'disguised', 'ðŸ˜Ž': 'sunglasses', 'ðŸ¤“': 'nerd', 'ðŸ§': 'monocle',
      'ðŸ˜•': 'confused', 'ðŸ˜Ÿ': 'worried', 'ðŸ™': 'slightly_frowning', 'â˜¹ï¸': 'frowning',
      'ðŸ˜®': 'open_mouth', 'ðŸ˜¯': 'hushed', 'ðŸ˜²': 'astonished', 'ðŸ˜³': 'flushed',
      'ðŸ¥º': 'pleading', 'ðŸ˜¦': 'frowning_open', 'ðŸ˜§': 'anguished', 'ðŸ˜¨': 'fearful',
      'ðŸ˜°': 'cold_sweat', 'ðŸ˜¥': 'disappointed_relieved', 'ðŸ˜¢': 'cry', 'ðŸ˜­': 'sob',
      'ðŸ˜±': 'scream', 'ðŸ˜–': 'confounded', 'ðŸ˜£': 'persevere', 'ðŸ˜ž': 'disappointed',
      'ðŸ˜“': 'sweat', 'ðŸ˜©': 'weary', 'ðŸ˜«': 'tired_face', 'ðŸ¥±': 'yawning',
      'ðŸ˜¤': 'triumph', 'ðŸ˜¡': 'rage', 'ðŸ˜ ': 'angry', 'ðŸ¤¬': 'cursing', 'ðŸ˜ˆ': 'smiling_imp',
      'ðŸ‘¿': 'imp', 'ðŸ’€': 'skull', 'â˜ ï¸': 'skull_crossbones', 'ðŸ’©': 'poop', 'ðŸ¤¡': 'clown',
      'ðŸ‘¹': 'ogre', 'ðŸ‘º': 'goblin', 'ðŸ‘»': 'ghost', 'ðŸ‘½': 'alien', 'ðŸ‘¾': 'space_invader',
      'ðŸ¤–': 'robot', 'ðŸ˜º': 'smiley_cat', 'ðŸ˜¸': 'smile_cat', 'ðŸ˜¹': 'joy_cat',
      'ðŸ˜»': 'heart_eyes_cat', 'ðŸ˜¼': 'smirk_cat', 'ðŸ˜½': 'kissing_cat',
      'ðŸ™€': 'scream_cat', 'ðŸ˜¿': 'crying_cat', 'ðŸ˜¾': 'pouting_cat',
      'â¤ï¸': 'heart', 'ðŸ§¡': 'orange_heart', 'ðŸ’›': 'yellow_heart', 'ðŸ’š': 'green_heart',
      'ðŸ’™': 'blue_heart', 'ðŸ’œ': 'purple_heart', 'ðŸ–¤': 'black_heart', 'ðŸ¤': 'white_heart',
      'ðŸ¤Ž': 'brown_heart', 'ðŸ’”': 'broken_heart', 'â£ï¸': 'heart_exclamation',
      'ðŸ’•': 'two_hearts', 'ðŸ’ž': 'revolving_hearts', 'ðŸ’“': 'heartbeat',
      'ðŸ’—': 'heartpulse', 'ðŸ’–': 'sparkling_heart', 'ðŸ’˜': 'cupid', 'ðŸ’': 'gift_heart',
      'ðŸ’Ÿ': 'heart_decoration', 'â˜®ï¸': 'peace', 'âœï¸': 'cross', 'â˜ªï¸': 'star_and_crescent',
      'ðŸ•‰ï¸': 'om', 'â˜¸ï¸': 'wheel_of_dharma', 'âœ¡ï¸': 'star_of_david', 'ðŸ”¯': 'six_pointed_star',
      'ðŸ•Ž': 'menorah', 'â˜¯ï¸': 'yin_yang', 'â˜¦ï¸': 'orthodox_cross', 'ðŸ›': 'place_of_worship',
      'â›Ž': 'ophiuchus', 'â™ˆ': 'aries', 'â™‰': 'taurus', 'â™Š': 'gemini', 'â™‹': 'cancer',
      'â™Œ': 'leo', 'â™': 'virgo', 'â™Ž': 'libra', 'â™': 'scorpio', 'â™': 'sagittarius',
      'â™‘': 'capricorn', 'â™’': 'aquarius', 'â™“': 'pisces', 'ðŸ†”': 'id', 'âš›ï¸': 'atom',
      'ðŸ‘': 'thumbsup', 'ðŸ‘Ž': 'thumbsdown', 'ðŸ‘Œ': 'ok_hand', 'âœŒï¸': 'v',
      'ðŸ¤ž': 'crossed_fingers', 'ðŸ¤Ÿ': 'love_you', 'ðŸ¤˜': 'metal', 'ðŸ¤™': 'call_me',
      'ðŸ‘ˆ': 'point_left', 'ðŸ‘‰': 'point_right', 'ðŸ‘†': 'point_up', 'ðŸ‘‡': 'point_down',
      'â˜ï¸': 'point_up_2', 'âœ‹': 'hand', 'ðŸ¤š': 'raised_back_of_hand', 'ðŸ–ï¸': 'hand_splayed',
      'ðŸ––': 'vulcan', 'ðŸ‘‹': 'wave', 'ðŸ¤™': 'call_me', 'ðŸ’ª': 'muscle', 'ðŸ¦¾': 'mechanical_arm',
      'ðŸ–•': 'middle_finger', 'âœï¸': 'writing_hand', 'ðŸ™': 'pray', 'ðŸ¦¶': 'foot',
      'ðŸ¦µ': 'leg', 'ðŸ¦¿': 'mechanical_leg', 'ðŸ’‹': 'kiss', 'ðŸ’„': 'lipstick',
      'ðŸ‘„': 'lips', 'ðŸ¦·': 'tooth', 'ðŸ‘…': 'tongue', 'ðŸ‘‚': 'ear', 'ðŸ¦»': 'ear_with_hearing_aid',
      'ðŸ‘ƒ': 'nose', 'ðŸ‘£': 'footprints', 'ðŸ‘ï¸': 'eye', 'ðŸ‘€': 'eyes', 'ðŸ§ ': 'brain',
      'ðŸ«€': 'anatomical_heart', 'ðŸ«': 'lungs', 'ðŸ©¸': 'drop_of_blood',
      'âœ…': 'white_check_mark', 'âœ”ï¸': 'check_mark', 'âŒ': 'x', 'âŽ': 'negative_squared_cross_mark',
      'â­': 'star', 'ðŸŒŸ': 'star2', 'ðŸ’«': 'dizzy', 'âš¡': 'zap', 'ðŸ”¥': 'fire',
      'ðŸ’¥': 'boom', 'ðŸ’¯': '100', 'ðŸŽ‰': 'tada', 'ðŸŽŠ': 'confetti_ball', 'ðŸŽˆ': 'balloon'
    };

    if (this.settings.replaceEmojis) {
      // Replace emojis with [emoji:name]
      return text.replace(/[\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]|[\u{FE00}-\u{FE0F}]|[\u{1F900}-\u{1F9FF}]|[\u{1F1E0}-\u{1F1FF}]/gu, (emoji) => {
        const name = emojiMap[emoji] || 'emoji';
        return `[emoji:${name}]`;
      });
    } else {
      // Remove emojis completely
      return text.replace(/[\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]|[\u{FE00}-\u{FE0F}]|[\u{1F900}-\u{1F9FF}]|[\u{1F1E0}-\u{1F1FF}]/gu, '');
    }
  }

  parseInlineFormatting(text) {
    // Handle emojis first (remove or replace)
    text = this.handleEmojis(text);

    // Replace footnote references with superscript numbers
    text = text.replace(/\[\^([^\]]+)\]/g, (_match, ref) => {
      return `^${ref}^`; // Temporary marker for superscript
    });

    const segments = [];
    let currentPos = 0;

    // Pattern matches: **bold**, *italic*, _italic_, `code`, [link](url), ^ref^ (footnote)
    // Updated regex to handle underscores for italics and footnote markers
    const regex = /(\*\*(.+?)\*\*)|(\*(.+?)\*)|(_(.+?)_)|(`(.+?)`)|(\[(.+?)\]\((.+?)\))|(\^([^\^]+)\^)/g;
    let match;

    while ((match = regex.exec(text)) !== null) {
      // Add text before the match as normal text
      if (match.index > currentPos) {
        segments.push({
          text: text.substring(currentPos, match.index),
          style: "normal"
        });
      }

      // Determine what type of formatting was matched
      if (match[1]) {
        // Bold: **text**
        segments.push({ text: match[2], style: "bold" });
      } else if (match[3]) {
        // Italic with asterisk: *text*
        segments.push({ text: match[4], style: "italic" });
      } else if (match[5]) {
        // Italic with underscore: _text_
        segments.push({ text: match[6], style: "italic" });
      } else if (match[7]) {
        // Code: `text`
        segments.push({ text: match[8], style: "code" });
      } else if (match[9]) {
        // Link: [text](url) - just show the text
        segments.push({ text: match[10], style: "normal" });
      } else if (match[12]) {
        // Footnote reference: ^ref^
        segments.push({ text: match[13], style: "superscript", footnoteRef: match[13] });
      }

      currentPos = regex.lastIndex;
    }

    // Add any remaining text
    if (currentPos < text.length) {
      segments.push({
        text: text.substring(currentPos),
        style: "normal"
      });
    }

    // If no formatting was found, return the whole text as normal
    if (segments.length === 0) {
      segments.push({ text: text, style: "normal" });
    }

    return segments;
  }

  markdownToPlainText(markdown) {
    const lines = [];
    const footnotes = {}; // Store footnote definitions
    const rawLines = markdown.split("\n");

    // First pass: collect all footnote definitions
    for (let rawLine of rawLines) {
      const footnoteDefMatch = rawLine.trim().match(/^\[\^([^\]]+)\]:\s*(.+)$/);
      if (footnoteDefMatch) {
        footnotes[footnoteDefMatch[1]] = footnoteDefMatch[2];
      }
    }

    // Store footnotes for later use in PDF generation
    this._footnotes = footnotes;

    for (let rawLine of rawLines) {
      // Skip footnote definition lines
      if (rawLine.trim().match(/^\[\^([^\]]+)\]:/)) {
        continue;
      }

      // Detect indentation level before trimming
      const indentMatch = rawLine.match(/^(\s*)/);
      const indentSpaces = indentMatch ? indentMatch[1].length : 0;
      // Calculate nesting level (handle tabs and varying space counts)
      // Tabs are typically 4 spaces, so normalize to levels
      let nestLevel = 0;
      if (indentSpaces > 0) {
        // If using tabs or 4+ spaces, treat as 1 level per 4 spaces
        // If using 2-3 spaces, treat as 1 level per 2 spaces
        if (indentSpaces >= 4) {
          nestLevel = Math.floor(indentSpaces / 4);
        } else {
          nestLevel = Math.floor(indentSpaces / 2);
        }
      }

      let line = rawLine.trim();
      if (!line) {
        lines.push({ segments: [{ text: "", style: "normal" }], type: "normal" });
        continue;
      }
      const headingMatch = line.match(/^(#{1,6})\s+(.+)/);
      if (headingMatch) {
        lines.push({
          segments: this.parseInlineFormatting(headingMatch[2]),
          type: "heading",
          level: headingMatch[1].length
        });
        continue;
      }
      if (line.startsWith("```")) {
        continue;
      }
      // Check for blockquotes
      const isBlockquote = line.startsWith(">");
      if (isBlockquote) {
        line = line.replace(/^>\s*/, "");
      }
      // Remove superscript syntax $^{number}$
      line = line.replace(/\$\^{(\d+)}\$/g, "$1");

      // Handle wiki-links
      if (this.settings.removeWikilinks) {
        // Remove all wikilinks completely
        line = line.replace(/\[\[([^\]|]+)\|([^\]]+)\]\]/g, "$2"); // [[link|display]] -> display
        line = line.replace(/\[\[([^\]|]+)\|\]\]/g, ""); // [[link|]] -> empty (hidden link)
        line = line.replace(/\[\[([^\]]+)\]\]/g, "$1"); // [[link]] -> link
      } else {
        // Keep wikilinks but format them
        line = line.replace(/\[\[([^\]|]+)\|\]\]/g, ""); // [[link|]] -> empty (hidden link)
        line = line.replace(/\[\[([^\]|]+)\|([^\]]+)\]\]/g, "$2"); // [[link|display]] -> display
        // Keep plain wikilinks as [[link]]
      }

      // Handle list markers
      const listMatch = line.match(/^[-*+]\s+(.+)/);
      if (listMatch) {
        // All levels use bullet, but with different opacity
        const bulletChar = "â€¢  ";

        lines.push({
          segments: [{ text: bulletChar, style: "normal", isBullet: true }, ...this.parseInlineFormatting(listMatch[1])],
          type: "list",
          isList: true,
          nestLevel: nestLevel
        });
        continue;
      }

      // Handle numbered lists
      const numberedMatch = line.match(/^(\d+)\.\s+(.+)/);
      if (numberedMatch) {
        lines.push({
          segments: [{ text: `${numberedMatch[1]}.  `, style: "normal" }, ...this.parseInlineFormatting(numberedMatch[2])],
          type: "list",
          isList: true,
          nestLevel: nestLevel
        });
        continue;
      }

      lines.push({
        segments: this.parseInlineFormatting(line),
        type: isBlockquote ? "blockquote" : "normal"
      });
    }
    return lines;
  }

  async loadJsPDF() {
    if (window.jspdf?.jsPDF) return;
    return new Promise((resolve, reject) => {
      const script = document.createElement("script");
      script.src = "https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js";
      script.onload = () => resolve();
      script.onerror = () => reject(new Error("Failed to load jsPDF"));
      document.head.appendChild(script);
    });
  }

  async sharePDF(blob, filename) {
    const pdfFolder = this.settings.pdfFolder;
    const pdfPath = `${pdfFolder}/${filename}.pdf`;
    try {
      if (!await this.app.vault.adapter.exists(pdfFolder)) {
        await this.app.vault.createFolder(pdfFolder);
      }

      // Check if file exists and warn if setting is enabled
      const fileExists = await this.app.vault.adapter.exists(pdfPath);
      if (fileExists && this.settings.warnOnOverwrite) {
        // Show confirmation modal
        return new Promise((resolve) => {
          const modal = new ConfirmOverwriteModal(
            this.app,
            filename,
            async () => {
              // User confirmed overwrite, proceed with save
              await this.savePDFFile(blob, pdfPath);
              resolve();
            },
            async (newFilename) => {
              // User wants to rename, recursively call with new name
              await this.sharePDF(blob, newFilename);
              resolve();
            }
          );
          modal.open();
        });
      }

      // No file exists or warning disabled, proceed with save
      await this.savePDFFile(blob, pdfPath);
    } catch (error) {
      console.error("Error saving PDF:", error);
      new import_obsidian.Notice(`Error saving PDF: ${error.message}`);
    }
  }

  async savePDFFile(blob, pdfPath) {
    try {
      const arrayBuffer = await blob.arrayBuffer();
      await this.app.vault.adapter.writeBinary(pdfPath, new Uint8Array(arrayBuffer));
      new import_obsidian.Notice(`PDF saved to ${pdfPath}`);

      // Extract filename from pdfPath for mobile sharing
      const filename = pdfPath.split('/').pop().replace('.pdf', '');

      if (import_obsidian.Platform.isMobile && navigator.share) {
        const file = new File([blob], `${filename}.pdf`, { type: "application/pdf" });
        const canShare = navigator.canShare ? navigator.canShare({ files: [file] }) : true;
        if (canShare) {
          try {
            await navigator.share({
              files: [file],
              title: filename
            });
          } catch (error) {
            if (error.name !== "AbortError") {
              console.error("Share failed:", error);
            }
          }
        }
      }
    } catch (error) {
      console.error("Save failed:", error);
      new import_obsidian.Notice(`Error saving PDF: ${error.message}`);
    }
  }

  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }

  async saveSettings() {
    await this.saveData(this.settings);
  }
};

var SharePDFSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl)
      .setName("PDF folder")
      .setDesc("Folder path where PDFs will be saved (relative to vault root)")
      .addText((text) =>
        text
          .setPlaceholder("PDFs")
          .setValue(this.plugin.settings.pdfFolder)
          .onChange(async (value) => {
            this.plugin.settings.pdfFolder = value || "PDFs";
            await this.plugin.saveSettings();
          })
      );
    new import_obsidian.Setting(containerEl)
      .setName("PDF naming style")
      .setDesc("Choose how to name the PDF file when sharing")
      .addDropdown((dropdown) =>
        dropdown
          .addOption("filename", "Use filename")
          .addOption("sentence-case", "Sentence-case filename")
          .addOption("sentence-case-date", "Sentence-case (date prefix)")
          .addOption("first-h1", "Use first H1 in document")
          .setValue(this.plugin.settings.pdfNamingStyle)
          .onChange(async (value) => {
            this.plugin.settings.pdfNamingStyle = value;
            await this.plugin.saveSettings();
          })
      );
    new import_obsidian.Setting(containerEl)
      .setName("Include frontmatter")
      .setDesc("Include YAML frontmatter in PDF")
      .addToggle((toggle) =>
        toggle
          .setValue(this.plugin.settings.includeFrontmatter)
          .onChange(async (value) => {
            this.plugin.settings.includeFrontmatter = value;
            await this.plugin.saveSettings();
          })
      );
    new import_obsidian.Setting(containerEl)
      .setName("Font size")
      .setDesc("Base font size for PDF (8-16pt)")
      .addSlider((slider) =>
        slider
          .setLimits(8, 16, 1)
          .setValue(this.plugin.settings.fontSize)
          .setDynamicTooltip()
          .onChange(async (value) => {
            this.plugin.settings.fontSize = value;
            await this.plugin.saveSettings();
          })
      );
    new import_obsidian.Setting(containerEl)
      .setName("Use theme CSS")
      .setDesc("Apply Obsidian theme's CSS variables to PDF")
      .addToggle((toggle) =>
        toggle
          .setValue(this.plugin.settings.useTheme)
          .onChange(async (value) => {
            this.plugin.settings.useTheme = value;
            await this.plugin.saveSettings();
          })
      );
    new import_obsidian.Setting(containerEl)
      .setName("Color mode")
      .setDesc("Override theme color mode for PDF generation")
      .addDropdown((dropdown) =>
        dropdown
          .addOption("auto", "Auto (use current theme)")
          .addOption("light", "Light mode")
          .addOption("dark", "Dark mode")
          .setValue(this.plugin.settings.colorMode)
          .onChange(async (value) => {
            this.plugin.settings.colorMode = value;
            await this.plugin.saveSettings();
          })
      );
    new import_obsidian.Setting(containerEl)
      .setName("Replace emojis with text")
      .setDesc("Replace emojis with [emoji:name] instead of removing them completely")
      .addToggle((toggle) =>
        toggle
          .setValue(this.plugin.settings.replaceEmojis)
          .onChange(async (value) => {
            this.plugin.settings.replaceEmojis = value;
            await this.plugin.saveSettings();
          })
      );
    new import_obsidian.Setting(containerEl)
      .setName("Show document title")
      .setDesc("Include document name at the top of the PDF")
      .addToggle((toggle) =>
        toggle
          .setValue(this.plugin.settings.includeTitle)
          .onChange(async (value) => {
            this.plugin.settings.includeTitle = value;
            await this.plugin.saveSettings();
          })
      );
    new import_obsidian.Setting(containerEl)
      .setName("Remove wikilinks")
      .setDesc("Remove [[wikilinks]] from the PDF (shows only the link text)")
      .addToggle((toggle) =>
        toggle
          .setValue(this.plugin.settings.removeWikilinks)
          .onChange(async (value) => {
            this.plugin.settings.removeWikilinks = value;
            await this.plugin.saveSettings();
          })
      );
    new import_obsidian.Setting(containerEl)
      .setName("Page margins")
      .setDesc("Margin width for PDF pages (normal matches Obsidian's settings)")
      .addDropdown((dropdown) =>
        dropdown
          .addOption("narrow", "Narrow")
          .addOption("normal", "Normal (match Obsidian)")
          .addOption("wide", "Wide")
          .setValue(this.plugin.settings.marginWidth)
          .onChange(async (value) => {
            this.plugin.settings.marginWidth = value;
            await this.plugin.saveSettings();
          })
      );
    new import_obsidian.Setting(containerEl)
      .setName("Warn before overwriting")
      .setDesc("Show confirmation dialog before overwriting existing PDF files")
      .addToggle((toggle) =>
        toggle
          .setValue(this.plugin.settings.warnOnOverwrite)
          .onChange(async (value) => {
            this.plugin.settings.warnOnOverwrite = value;
            await this.plugin.saveSettings();
          })
      );
    new import_obsidian.Setting(containerEl)
      .setName("Show page numbers")
      .setDesc("Display page numbers at the bottom of each page")
      .addToggle((toggle) =>
        toggle
          .setValue(this.plugin.settings.showPageNumbers)
          .onChange(async (value) => {
            this.plugin.settings.showPageNumbers = value;
            await this.plugin.saveSettings();
          })
      );
    new import_obsidian.Setting(containerEl)
      .setName("Page number alignment")
      .setDesc("Horizontal alignment for page numbers")
      .addDropdown((dropdown) =>
        dropdown
          .addOption("left", "Left")
          .addOption("center", "Center")
          .addOption("right", "Right")
          .setValue(this.plugin.settings.pageNumberAlignment)
          .onChange(async (value) => {
            this.plugin.settings.pageNumberAlignment = value;
            await this.plugin.saveSettings();
          })
      );
    new import_obsidian.Setting(containerEl)
      .setName("CSS theme override")
      .setDesc("Custom CSS to override theme styles (e.g., --font-text-theme, --h1-color)")
      .addTextArea((text) => {
        text
          .setPlaceholder("body { --font-text-theme: Helvetica; --h1-color: #000000; }")
          .setValue(this.plugin.settings.cssOverride)
          .onChange(async (value) => {
            this.plugin.settings.cssOverride = value;
            await this.plugin.saveSettings();
          });
        text.inputEl.style.height = "150px"; // Taller textarea
        return text;
      });
  }
};